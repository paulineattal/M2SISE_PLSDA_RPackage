########
#Appel de la nipals pour effectuer la regression PLS#
nipals.res <- plslda.nipals(X=X, y=ydum, ncomp=ncomp , max.iter=max.iter, tol=tol)
#####
#LDA#
#####
#ici on effectue la LDA pour la classification
#on l'a fait sur nos compossntes principales Th, obtenues en sorties de la PLS
Th <- nipals.res$comp_X
#effectif par classe
n_k <- table(y)
#nombre d'individus
n <- nrow(Th)
#nombre de modalite
K <- nlevels(y)
#nombre de variables desc
p <- ncol(Th)
#proportion par classe
pi_k <- n_k / n
#calcul des moyennes conditionelles - lignes = classes
mb_k <- as.matrix(aggregate(Th,list(y),mean)[,2:(p+1)])
#calcul des matrices de covariances conditionnelles
V_k <- by(as.matrix(Th),list(y),cov)
#matrice de covariance intra-classe W
#calculée à partir des matrices conditionnelles V_k
W <- 1/(n-K) * Reduce("+",lapply(levels(y),function(k){(n_k[k]-1)*V_k[[k]]}))
#inverse de la matrice W
invW <- solve(W)
#calcul des coefficients des variables akj
#pour la fonction de classement
coef_ <- t(mb_k %*% invW)
colnames(coef_) <- levels(y)
intercept_ <- log(pi_k)-0.5*diag(mb_k %*% invW %*% t(mb_k))
######################################
#revenir a toutes les var originelles#
######################################
coef_ <- as.matrix(nipals.res$poid_X)%*%coef_
coef_ <- diag(1/apply(X.init, 2, sd)) %*% coef_
intercept_ <- as.vector(-apply(X.init, 2, mean) %*% coef_) #TODO corriger ce calcul...
#mettre dans un data.frame les coef et constant pour le print
coef <- data.frame(Attributes = colnames(X),coef_)
cte <- data.frame(Attributes = "constant",t(intercept_))
colnames(cte)[1:K+1] <- levels(y)
coef_cte <- rbind(coef,cte)
##################################
#stockage des resultats de sortie#
##################################
res <- list("comp_X"= nipals.res$comp_X,
"poid_X" = nipals.res$poid_X,
"comp_Y" = nipals.res$comp_Y,
"poid_Y" = nipals.res$poid_Y,
"quality" = nipals.res$quality,
"intercept_" = intercept_,
"coef_"=coef_,
"coef_cte" = coef_cte,
"X.init" = X.init,
"y" = y)
class(res)<-"PLSDA"
return(res)
}
data(iris)
plsda.fit(Species~., iris)
setwd('/home/pierre/Documents/Master/Semestre_1/R/projet/PLSDA_R_Package/code')
source('./split_sample.r')
source('./sel_forward.R')
source('./plot.R')
source('./fit.R')
source('./cv.R')
source('./scale.r')
source('./dummies.r')
source('./nipals.r')
plslda.fit <- function(formula, data,
ncomp = 2, #ici on peut mettre "CV"
max.iter = 100,
tol = 1e-06)
{
###########################
#verifications des entrées#
###########################
if ((missing(data) | missing(formula))){
stop("formula et data sont les deux parametres obligatoires")
}
#formula au bon type
if(plyr::is.formula(formula)==F){
stop("formula doit etre de type formule")
}
#data est un data.frame ?
if (!is.data.frame(data)){
stop("data doit être un data.frame")
}
#ligne.s ou colonne.s entierement vide.s ?
if (any(colSums(!is.na(data)) == 0) | any(rowSums(!is.na(data)) == 0 )){
stop("certaines lignes ou colonnes sont entierements manquantes",
"Retirez-les avant de relancer la fonction fit().", call. = FALSE)
}
#Récupération des X et Y
X <- as.matrix(model.matrix(formula, data = data)[,-1])
X.init <- X
y <- as.factor(model.response(model.frame(formula, data = data)))
#type des variables X toutes numeriques
nbNumeric<- sum(sapply(X,is.numeric))
if(nbNumeric<ncol(X)){
stop("certaines variables ne sont pas numeriques")
}
#lancer les traitements correspondant aux parametrages
#param ncomp
#choix du nombre idéal de composantes principales
if(ncomp == "CV") {
ncomp = plslda.cv()$ncomp
}else if(!is.numeric(ncomp) || is.null(ncomp) || ncomp <= 0 || length(ncomp)>1){
stop("parametre ncomp doit etre un numerique ")
}else if(ncomp > qr(X)$rank){
ncomp <- qr(X)$rank
}
#####################
#preparer les X et y#
#####################
#si X est a standardiser
if ((round(mean(apply(X,2,mean))) != 0) || (sum(sqrt(apply(X,2,var))) != ncol(X))){
X <- plsda.scale(X)
}
#codage disjonctif de la variable cible
ydum <- plsda.dummies(y)
########
#NIPALS#
########
#Appel de la nipals pour effectuer la regression PLS#
nipals.res <- plslda.nipals(X=X, y=ydum, ncomp=ncomp , max.iter=max.iter, tol=tol)
#####
#LDA#
#####
#ici on effectue la LDA pour la classification
#on l'a fait sur nos compossntes principales Th, obtenues en sorties de la PLS
Th <- nipals.res$comp_X
#effectif par classe
n_k <- table(y)
#nombre d'individus
n <- nrow(Th)
#nombre de modalite
K <- nlevels(y)
#nombre de variables desc
p <- ncol(Th)
#proportion par classe
pi_k <- n_k / n
#calcul des moyennes conditionelles - lignes = classes
mb_k <- as.matrix(aggregate(Th,list(y),mean)[,2:(p+1)])
#calcul des matrices de covariances conditionnelles
V_k <- by(as.matrix(Th),list(y),cov)
#matrice de covariance intra-classe W
#calculée à partir des matrices conditionnelles V_k
W <- 1/(n-K) * Reduce("+",lapply(levels(y),function(k){(n_k[k]-1)*V_k[[k]]}))
#inverse de la matrice W
invW <- solve(W)
#calcul des coefficients des variables akj
#pour la fonction de classement
coef_ <- t(mb_k %*% invW)
colnames(coef_) <- levels(y)
intercept_ <- log(pi_k)-0.5*diag(mb_k %*% invW %*% t(mb_k))
######################################
#revenir a toutes les var originelles#
######################################
coef_ <- as.matrix(nipals.res$poid_X)%*%coef_
coef_ <- diag(1/apply(X.init, 2, sd)) %*% coef_
intercept_ <- as.vector(-apply(X.init, 2, mean) %*% coef_) #TODO corriger ce calcul...
#mettre dans un data.frame les coef et constant pour le print
coef <- data.frame(Attributes = colnames(X),coef_)
cte <- data.frame(Attributes = "constant",t(intercept_))
colnames(cte)[1:K+1] <- levels(y)
coef_cte <- rbind(coef,cte)
##################################
#stockage des resultats de sortie#
##################################
res <- list("comp_X"= nipals.res$comp_X,
"poid_X" = nipals.res$poid_X,
"comp_Y" = nipals.res$comp_Y,
"poid_Y" = nipals.res$poid_Y,
"quality" = nipals.res$quality,
"intercept_" = intercept_,
"coef_"=coef_,
"coef_cte" = coef_cte,
"X.init" = X.init,
"y" = y)
class(res)<-"PLSDA"
return(res)
}
data(iris)
plsda.fit(Species~., iris)
setwd('/home/pierre/Documents/Master/Semestre_1/R/projet/PLSDA_R_Package/code')
source('./split_sample.r')
source('./sel_forward.R')
source('./plot.R')
source('./fit.R')
source('./cv.R')
source('./scale.r')
source('./dummies.r')
source('./nipals.r')
plslda.fit <- function(formula, data,
ncomp = 2, #ici on peut mettre "CV"
max.iter = 100,
tol = 1e-06)
{
###########################
#verifications des entrées#
###########################
if ((missing(data) | missing(formula))){
stop("formula et data sont les deux parametres obligatoires")
}
#formula au bon type
if(plyr::is.formula(formula)==F){
stop("formula doit etre de type formule")
}
#data est un data.frame ?
if (!is.data.frame(data)){
stop("data doit être un data.frame")
}
#ligne.s ou colonne.s entierement vide.s ?
if (any(colSums(!is.na(data)) == 0) | any(rowSums(!is.na(data)) == 0 )){
stop("certaines lignes ou colonnes sont entierements manquantes",
"Retirez-les avant de relancer la fonction fit().", call. = FALSE)
}
#Récupération des X et Y
X <- as.matrix(model.matrix(formula, data = data)[,-1])
X.init <- X
y <- as.factor(model.response(model.frame(formula, data = data)))
#type des variables X toutes numeriques
nbNumeric<- sum(sapply(X,is.numeric))
if(nbNumeric<ncol(X)){
stop("certaines variables ne sont pas numeriques")
}
#lancer les traitements correspondant aux parametrages
#param ncomp
#choix du nombre idéal de composantes principales
if(ncomp == "CV") {
ncomp = plslda.cv()$ncomp
}else if(!is.numeric(ncomp) || is.null(ncomp) || ncomp <= 0 || length(ncomp)>1){
stop("parametre ncomp doit etre un numerique ")
}else if(ncomp > qr(X)$rank){
ncomp <- qr(X)$rank
}
#####################
#preparer les X et y#
#####################
#si X est a standardiser
if ((round(mean(apply(X,2,mean))) != 0) || (sum(sqrt(apply(X,2,var))) != ncol(X))){
X <- plsda.scale(X)
}
#codage disjonctif de la variable cible
ydum <- plsda.dummies(y)
########
#NIPALS#
########
#Appel de la nipals pour effectuer la regression PLS#
nipals.res <- plslda.nipals(X=X, y=ydum, ncomp=ncomp , max.iter=max.iter, tol=tol)
#####
#LDA#
#####
#ici on effectue la LDA pour la classification
#on l'a fait sur nos compossntes principales Th, obtenues en sorties de la PLS
Th <- nipals.res$comp_X
#effectif par classe
n_k <- table(y)
#nombre d'individus
n <- nrow(Th)
#nombre de modalite
K <- nlevels(y)
#nombre de variables desc
p <- ncol(Th)
#proportion par classe
pi_k <- n_k / n
#calcul des moyennes conditionelles - lignes = classes
mb_k <- as.matrix(aggregate(Th,list(y),mean)[,2:(p+1)])
#calcul des matrices de covariances conditionnelles
V_k <- by(as.matrix(Th),list(y),cov)
#matrice de covariance intra-classe W
#calculée à partir des matrices conditionnelles V_k
W <- 1/(n-K) * Reduce("+",lapply(levels(y),function(k){(n_k[k]-1)*V_k[[k]]}))
#inverse de la matrice W
invW <- solve(W)
#calcul des coefficients des variables akj
#pour la fonction de classement
coef_ <- t(mb_k %*% invW)
colnames(coef_) <- levels(y)
intercept_ <- log(pi_k)-0.5*diag(mb_k %*% invW %*% t(mb_k))
######################################
#revenir a toutes les var originelles#
######################################
coef_ <- as.matrix(nipals.res$poid_X)%*%coef_
coef_ <- diag(1/apply(X.init, 2, sd)) %*% coef_
intercept_ <- as.vector(-apply(X.init, 2, mean) %*% coef_) #TODO corriger ce calcul...
#mettre dans un data.frame les coef et constant pour le print
coef <- data.frame(Attributes = colnames(X),coef_)
cte <- data.frame(Attributes = "constant",t(intercept_))
colnames(cte)[1:K+1] <- levels(y)
coef_cte <- rbind(coef,cte)
##################################
#stockage des resultats de sortie#
##################################
res <- list("comp_X"= nipals.res$comp_X,
"poid_X" = nipals.res$poid_X,
"comp_Y" = nipals.res$comp_Y,
"poid_Y" = nipals.res$poid_Y,
"quality" = nipals.res$quality,
"intercept_" = intercept_,
"coef_"=coef_,
"coef_cte" = coef_cte,
"X.init" = X.init,
"y" = y)
class(res)<-"PLSDA"
return(res)
}
data(iris)
plsda.fit(Species~., iris)
shiny::runApp()
runApp()
runApp()
runApp()
test <- 'PC1 tetstst'
grep('PC', test)
test <- 'PC1 tetstst'
gsub('PC', test)
test <- 'PC1 tetstst'
gsub('PC',"", test)
regmatches(test, regexpr('PC\d{1:', test))
regmatches(test, regexpr('[A-Z]{2}\d{1:}', test))
regmatches(test, regexpr('[A-Z]{2}', test))
regmatches(test, regexpr('[A-Z]{2}[0-9]{1:}', test))
regmatches(test, regexpr('[A-Z]{2}[0-9]{1,}', test))
runApp()
regmatches(test, regexpr('[A-Z]{2}[0-9]{1,}', test))
test <- 'PC1 tetstst PC2'
regmatches(test, regexpr('[A-Z]{2}[0-9]{1,}', test))
test <- 'PC1 tetstst PC2'
regmatches(test, regexpr('[A-Z]{2}[0-9]{1}', test))
test <- 'PC1 tetstst PC2'
regmatches(test, regexpr('[A-Z]{2}\\d{1}', test))
sub("[A-Z]{2}\\d{1,}","",test)
sub("[A-Z]{2}\\d{1,}"," ",test)
test <- 'PC1 tetstst PC2'
sub("[A-Z]{2}\\d{1,}"," ",test)
substring(test, regexpr("[A-Z]{2}\\d{1,}", test)+1)
substring(test, regexpr("[A-Z]{2}\\d{1,}", test))
substring(split(test," "), regexpr("[A-Z]{2}\\d{1,}", test))
regmatches(test, regexpr('[A-Z]{2}\\d{1,}',test))
split(test, " ")
split(test, " ")[1]
strsplit(test, " ")[1]
strsplit(test, " ")
regmatches(test, regexpr('[A-Z]{2}\\d{1,}',strsplit(test)))
sapply(regmatches(strsplit(test, " "), regexpr('[A-Z]{2}\\d{1,}'), test))
library(stringr)
library(stringr)
regmatches(gsub(" ", "", test), regexpr('[A-Z]{2}\\d{1,}',strsplit(test)))
regmatches(gsub(" ", "", test), regexpr('[A-Z]{2}\\d{1,}',test))
regmatches(gsub(" ", "", test), regexpr('[A-Z]{2}\\d',test))
regmatches(gsub(" ", "", test), regexpr('[A-Z]{2}\\d',gsub(" ","", test)))
gsub(" ","", test)
test <- gsub(" ","", test)
gsub("[A-Z]{2}\\d{1}", "", test)
gsub("^[A-Z]{2}\\d{1}", "", test)
gsub("[^[A-Z]{2}\\d{1}]", "", test)
test <- 'PC1 tetstst PC2'
sub("[A-Z]{2}\\d{1,}", test, perl = TRUE)
sub("[A-Z]{2}\\d{1,}","\\1" test, perl = TRUE)
install.packages('stringr')
library(stringr)
strsplit(test, ' ')
(strsplit(test, ' '))[0]
strsplit(test, ' ')
(strsplit(test, ' '))[1]
runApp()
setwd('/home/pierre/Documents/Master/Semestre_1/R/projet/PLSDA_R_Package/code/')
files = list.files(pattern=c('*.R', '*.r'))
sapply(files, load)
setwd('/home/pierre/Documents/Master/Semestre_1/R/projet/PLSDA_R_Package/code/')
files = list.files(pattern=c('*.R', '*.r'))
sapply(files, load)
source('./dummies.r')
setwd('/home/pierre/Documents/Master/Semestre_1/R/projet/PLSDA_R_Package/code/')
source('./cv.R')
source('./dummies.r')
source('./nipals.r')
source('./predict.R')
source('./scale.r')
source('./sel_forward.R')
source('./split_sample.r')
plslda.fit <- function(formula, data,
ncomp = 2, #ici on peut mettre "CV"
max.iter = 100,
tol = 1e-06)
{
###########################
#verifications des entrées#
###########################
if ((missing(data) | missing(formula))){
stop("formula et data sont les deux parametres obligatoires")
}
#formula au bon type
if(plyr::is.formula(formula)==F){
stop("formula doit etre de type formule")
}
#data est un data.frame ?
if (!is.data.frame(data)){
stop("data doit être un data.frame")
}
#ligne.s ou colonne.s entierement vide.s ?
if (any(colSums(!is.na(data)) == 0) | any(rowSums(!is.na(data)) == 0 )){
stop("certaines lignes ou colonnes sont entierements manquantes",
"Retirez-les avant de relancer la fonction fit().", call. = FALSE)
}
#Récupération des X et Y
X <- as.matrix(model.matrix(formula, data = data)[,-1])
X.init <- X
y <- as.factor(model.response(model.frame(formula, data = data)))
#type des variables X toutes numeriques
nbNumeric<- sum(sapply(X,is.numeric))
if(nbNumeric<ncol(X)){
stop("certaines variables ne sont pas numeriques")
}
#lancer les traitements correspondant aux parametrages
#param ncomp
#choix du nombre idéal de composantes principales
if(ncomp == "CV") {
ncomp = plsda.cv()$ncomp
}else if(!is.numeric(ncomp) || is.null(ncomp) || ncomp <= 0 || length(ncomp)>1){
stop("parametre ncomp doit etre un numerique ")
}else if(ncomp > qr(X)$rank){
ncomp <- qr(X)$rank
}
#####################
#preparer les X et y#
#####################
#si X est a standardiser
if ((round(mean(apply(X,2,mean))) != 0) || (sum(sqrt(apply(X,2,var))) != ncol(X))){
X <- plsda.scale(X)
}
#codage disjonctif de la variable cible
ydum <- plsda.dummies(y)
########
#NIPALS#
########
#Appel de la nipals pour effectuer la regression PLS#
nipals.res <- plslda.nipals(X=X, y=ydum, ncomp=ncomp , max.iter=max.iter, tol=tol)
#####
#LDA#
#####
#ici on effectue la LDA pour la classification
#on l'a fait sur nos compossntes principales Th, obtenues en sorties de la PLS
Th <- nipals.res$comp_X
#effectif par classe
n_k <- table(y)
#nombre d'individus
n <- nrow(Th)
#nombre de modalite
K <- nlevels(y)
#nombre de variables desc
p <- ncol(Th)
#proportion par classe
pi_k <- n_k / n
#calcul des moyennes conditionelles - lignes = classes
mb_k <- as.matrix(aggregate(Th,list(y),mean)[,2:(p+1)])
#calcul des matrices de covariances conditionnelles
V_k <- by(as.matrix(Th),list(y),cov)
#matrice de covariance intra-classe W
#calculée à partir des matrices conditionnelles V_k
W <- 1/(n-K) * Reduce("+",lapply(levels(y),function(k){(n_k[k]-1)*V_k[[k]]}))
#inverse de la matrice W
invW <- solve(W)
#calcul des coefficients des variables akj
#pour la fonction de classement
coef_ <- t(mb_k %*% invW)
colnames(coef_) <- levels(y)
intercept_ <- log(pi_k)-0.5*diag(mb_k %*% invW %*% t(mb_k))
######################################
#revenir a toutes les var originelles#
######################################
coef_ <- as.matrix(nipals.res$poid_X)%*%coef_
coef_ <- diag(1/apply(X.init, 2, sd)) %*% coef_
intercept_ <- as.vector(-apply(X.init, 2, mean) %*% coef_) #TODO corriger ce calcul...
#mettre dans un data.frame les coef et constant pour le print
coef <- data.frame(Attributes = colnames(X),coef_)
cte <- data.frame(Attributes = "constant",t(intercept_))
colnames(cte)[1:K+1] <- levels(y)
coef_cte <- rbind(coef,cte)
##################################
#stockage des resultats de sortie#
##################################
res <- list("comp_X"= nipals.res$comp_X,
"poid_X" = nipals.res$poid_X,
"comp_Y" = nipals.res$comp_Y,
"poid_Y" = nipals.res$poid_Y,
"quality" = nipals.res$quality,
"intercept_" = intercept_,
"coef_"=coef_,
"coef_cte" = coef_cte,
"X.init" = X.init,
"y" = y)
class(res)<-"PLSDA"
return(res)
}
plslda.fit(Species~.,iris)
plslda.fit(Species~.,iris)$comp_X
colnames(plslda.fit(Species~.,iris)$comp_X))
colnames(plslda.fit(Species~.,iris)$comp_X)
runApp('~/Documents/Master/Semestre_1/R/projet/PLSDA_R_Package/Rshiny')
runApp('~/Documents/Master/Semestre_1/R/projet/PLSDA_R_Package/Rshiny')
runApp('~/Documents/Master/Semestre_1/R/projet/PLSDA_R_Package/Rshiny')
runApp('~/Documents/Master/Semestre_1/R/projet/PLSDA_R_Package/Rshiny')
runApp('~/Documents/Master/Semestre_1/R/projet/PLSDA_R_Package/Rshiny')
runApp('~/Documents/Master/Semestre_1/R/projet/PLSDA_R_Package/Rshiny')
runApp('~/Documents/Master/Semestre_1/R/projet/PLSDA_R_Package/Rshiny')
runApp('~/Documents/Master/Semestre_1/R/projet/PLSDA_R_Package/Rshiny')
runApp('~/Documents/Master/Semestre_1/R/projet/PLSDA_R_Package/Rshiny')
