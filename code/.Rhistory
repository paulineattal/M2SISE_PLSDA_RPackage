th = x0 %*% ph / colSums(P2)
} else {
th = x %*% ph / sum(ph*ph)
}
# Gram Schmidt orthogonalization # t = t - (Th)(Th)' t
if(gramschmidt && h>1) {
th <- th - TTp %*% th
}
# check convergence of th
if( sum((th-th.old)^2, na.rm=TRUE)<tol ) continue=FALSE
pciter <- pciter + 1
if (pciter == maxiter) {
continue <- FALSE
warning("Stopping after ", maxiter, " iterations for PC ", h,".\n")
}
if (verbose >= 1) cat(".")
} # iterations for PC h
if (verbose >= 1) cat("\n")
# deflate/remove variation from x explained by PC h, x=x-tp'
x <- x - (th %*% t(ph))
loadings[,h] <- ph
scores[,h] <- th
eig[h]  <- sum(th*th, na.rm=TRUE)
iter[h] <- pciter
# Update (Ph)(Ph)' and (Th)(Th)' for next PC
if(gramschmidt) {
PPp = PPp + tcrossprod(ph)          # PP' = PP' + (ph)(ph)'
TTp = TTp + tcrossprod(th) / eig[h] # TT' = TT' = (th)(th)'
}
# Cumulative proportion of variance explained
R2cum[h] <- 1 - (sum(x*x,na.rm=TRUE) / TotalSS)
} # Done finding PCs
# un-cumulate R2
R2 <- c(R2cum[1], diff(R2cum))
# sweep out eigenvalues from scores
eig = sqrt(eig)
scores = sweep(scores, 2, eig, "/")
if(fitted) {
# re-construction of x using ncomp principal components
# must use diag( nrow=length(eig)) because diag(3.3) is a 3x3 identity
# xhat <- tcrossprod( tcrossprod(scores,diag(eig, nrow=length(eig))), loadings)
xhat <- tcrossprod( sweep( scores, 2, eig, "*") , loadings)
if(scale) xhat <- sweep(xhat, 2, csds, "*")
if(center) xhat <- sweep(xhat, 2, cmeans, "+")
rownames(xhat) <- rownames(x.orig)
colnames(xhat) <- colnames(x.orig)
} else {
xhat <- NULL
}
rownames(scores) <- rownames(x)
colnames(scores) <- paste("PC", 1:ncol(scores), sep="")
rownames(loadings) <- colnames(x)
colnames(loadings) <- paste("PC", 1:ncol(loadings), sep="")
out <- list(eig=eig,
scores=scores,
loadings=loadings,
fitted=xhat,
ncomp=ncomp,
R2=R2,
iter=iter,
center=cmeans, scale=csds)
return(out)
}
if(FALSE){
B <- matrix(c(50, 67, 90, 98, 120,
55, 71, 93, 102, 129,
65, 76, 95, 105, 134,
50, 80, 102, 130, 138,
60, 82, 97, 135, 151,
65, 89, 106, 137, 153,
75, 95, 117, 133, 155), ncol=5, byrow=TRUE)
rownames(B) <- c("G1","G2","G3","G4","G5","G6","G7")
colnames(B) <- c("E1","E2","E3","E4","E5")
B2 = B
B2[1,1] = B2[2,1] = NA
m4 <- nipals(B2, ncomp=5)
m4$eig
}
nipals(B)
data('iris')
library('fastDummies')
#séparation du dataframe entre target et vriables explicatives
target <- iris['Species']
expl <- iris[, names(iris)!='Species']
expl
expl_center <- scale(expl, scale = F)
data('iris')
library('fastDummies')
iris <- dummy_cols(iris, select_columns = Species, remove_selected_columns = T)
#séparation du dataframe entre target et vriables explicatives
target <- iris[-5]
target
data('iris')
library('fastDummies')
iris <- dummy_cols(iris, select_columns = Species, remove_selected_columns = T)
iris
iris <- dummy_cols(iris, select_columns = Species, remove_selected_columns = T)
iris
data('iris')
library('fastDummies')
iris <- dummy_cols(iris, select_columns = 'Species', remove_selected_columns = T)
iris
target <- iris[-3]
target
target <- iris[-6]
target
target <- iris[-9]
target
target <- iris[-2]
target
target <- iris['Species']
data('iris')
library('fastDummies')
target <- iris['Species']
expl <- iris[, name(iris)!='Species']
data('iris')
library('fastDummies')
target <- iris['Species']
expl <- iris[, names(iris)!='Species']
target <- dummy_cols(target, select_columns = 'Species', remove_selected_columns = T)
target
expl
expl_center <- scale(expl, scale = F)
pca <- prcomp(expl, scale. = T)
pca
data('iris')
library('fastDummies')
target <- iris['Species']
expl <- iris[, names(iris)!='Species']
target <- dummy_cols(target, select_columns = 'Species', remove_selected_columns = T)
expl_center <- scale(expl, scale = F)
pca <- prcomp(expl, scale. = F)
pca
100 * pca$sdev^2/sum(pca$sdev^2)
#On calcule le pourcentage pour savoir quels variables garder
100 * pca$sdev^2/sum(pca$sdev^2)
pca$x
plot(pca$x)
plot(pca$x[,3:4])
data('iris')
tmp.data <- iris[,5]
tmp.data
tmp.group <- iris[,5]
tmp.group
tmp.data <- iris[,-5]
tmp.group <- iris[,5]
tmp.group
tmp.data
tmp.y <- matrix(as.numeric(tmp.group), ncol=1)
tmp.y
plsda.pls(Species~., iris, ncomp=2)
data('iris')
plsda.pls <- function(formula, data, ncomp, center = F){
#Vérification que l'entrée est bien une formule Y~X
if(plyr::is.formula(formula)==F){
stop("formula must be R formula !")
}
#Récupération des X et Y
X <- model.matrix(formula, data = data)
X <- X[,-1] #suppression de l'intercept
Y <- model.response(model.frame(formula, data = data))
# Cohérence de Y
if(is.factor(Y)==F && is.vector(Y)==F){stop("Dimension de Y incorrecte") }
if(!(is.factor(Y))){ Y <- as.factor(Y) }
x <- as.matrix(X)
#si le jeu de données entré n'est pas centré
if(center == T){
x <- plsda.scale(X)
x <- as.matrix(x$New, ncol = 1)
}
y.dummies <- plsda.dummies(Y)
#initialisation de la matrice des poids des composantes de X
W <- data.frame(matrix(rep(0), nrow = ncol(x), ncol=ncomp))
rownames(W) <- colnames(x)
#initialisation de la matrice des composantes de X
P <- data.frame(matrix(rep(0), nrow = ncol(x), ncol=ncomp))
rownames(P) <- colnames(x)
#initialisation de la matrice des scores de X
Tx <- data.frame(matrix(rep(0), nrow = nrow(x), ncol=ncomp))
#initialisation de la matrice des scores de Y
U <- data.frame(matrix(rep(0), nrow = nrow(x), ncol=ncomp))
#initialisation de la matrice des composantes de Y
Q <- data.frame(matrix(rep(0), nrow = ncol(y.dummies), ncol = ncomp))
rownames(Q) <- colnames(y.dummies)
#on déroule l'algorithme NIPALS pour calculer les composantes de X et Y
for(i in 1:ncomp){
#on associe à u la première colonne de Yk-1
u <- as.matrix(y.dummies[,1])
j <- 1
w <- W[,1]
init <- (t(x)%*%u)/sum(u^2)
#on normalise w
init <- init/sqrt(sum(init^2))
#on boucle jusqu'à ce que w converge
while(abs(mean(w)-mean(init)) > 1e-10){
#on n'associe pas init à w au premier tour
if(j > 1){
init <- w
}
#on calcule la composante t de la matrice Xk-1
t <- x%*%init
#calcul des poids de Yk-1
q <- t(y.dummies)%*%t/sum(t^2)
#calcul de la composante u de Xk-1
u <- (y.dummies%*%q)/sum(q^2)
#on met à jour le vecteur de poids
w <- (t(x)%*%u)/sum(u^2)
#on normalise w
w <- w/sqrt(sum(w^2))
j <- j+1
}
#SVD de Y
U[,i] <- u
#SVD de X
Tx[,i] <- t
#matrice des composantes de Y
Q[,i] <- q
#matrice des composantes "loadings" de la pls de R
P[,i] <- t(x)%*%x%*%w
c <- t(w)%*%t(x)%*%x%*%w
P[,i] <- P[,i]/as.numeric(c)
#mise à jour de la matrice des X
x <- as.matrix(x - t%*%t(P[,i]))
#mise à jour des Y
y.dummies <- y.dummies - t%*%t(q)
#on stocke le vecteur des poids de la composante i dans W[,i]
W[,i] <- w
}
train_pls <- data.frame(Y, Tx)
R2 <- cor(y.dummies, Tx)^2
res <- list("X"=X,
"Y"=Y,
"Yloadings" = Q,
"Yscores" = U,
"Xloadings"= P,
"Xloading.weights" = W,
"Xscores" = Tx,
"TrainPlsData" = train_pls,
"R2" = R2
)
class(res)<-"PLS"
return(res)
}
plsda.pls(Species~., iris, ncomp=2)
library('fastdummies')
library('fastDummies')
data('iris')
library('fastDummies')
plsda.pls <- function(formula, data, ncomp, center = F){
#Vérification que l'entrée est bien une formule Y~X
if(plyr::is.formula(formula)==F){
stop("formula must be R formula !")
}
#Récupération des X et Y
X <- model.matrix(formula, data = data)
X <- X[,-1] #suppression de l'intercept
Y <- model.response(model.frame(formula, data = data))
# Cohérence de Y
if(is.factor(Y)==F && is.vector(Y)==F){stop("Dimension de Y incorrecte") }
if(!(is.factor(Y))){ Y <- as.factor(Y) }
x <- as.matrix(X)
#si le jeu de données entré n'est pas centré
if(center == T){
x <- plsda.scale(X)
x <- as.matrix(x$New, ncol = 1)
}
y.dummies <- plsda.dummies(Y)
y.dummies <- dummy_cols(Y, select_columns = 'Species', remove_selected_columns = T)
#initialisation de la matrice des poids des composantes de X
W <- data.frame(matrix(rep(0), nrow = ncol(x), ncol=ncomp))
rownames(W) <- colnames(x)
#initialisation de la matrice des composantes de X
P <- data.frame(matrix(rep(0), nrow = ncol(x), ncol=ncomp))
rownames(P) <- colnames(x)
#initialisation de la matrice des scores de X
Tx <- data.frame(matrix(rep(0), nrow = nrow(x), ncol=ncomp))
#initialisation de la matrice des scores de Y
U <- data.frame(matrix(rep(0), nrow = nrow(x), ncol=ncomp))
#initialisation de la matrice des composantes de Y
Q <- data.frame(matrix(rep(0), nrow = ncol(y.dummies), ncol = ncomp))
rownames(Q) <- colnames(y.dummies)
#on déroule l'algorithme NIPALS pour calculer les composantes de X et Y
for(i in 1:ncomp){
#on associe à u la première colonne de Yk-1
u <- as.matrix(y.dummies[,1])
j <- 1
w <- W[,1]
init <- (t(x)%*%u)/sum(u^2)
#on normalise w
init <- init/sqrt(sum(init^2))
#on boucle jusqu'à ce que w converge
while(abs(mean(w)-mean(init)) > 1e-10){
#on n'associe pas init à w au premier tour
if(j > 1){
init <- w
}
#on calcule la composante t de la matrice Xk-1
t <- x%*%init
#calcul des poids de Yk-1
q <- t(y.dummies)%*%t/sum(t^2)
#calcul de la composante u de Xk-1
u <- (y.dummies%*%q)/sum(q^2)
#on met à jour le vecteur de poids
w <- (t(x)%*%u)/sum(u^2)
#on normalise w
w <- w/sqrt(sum(w^2))
j <- j+1
}
#SVD de Y
U[,i] <- u
#SVD de X
Tx[,i] <- t
#matrice des composantes de Y
Q[,i] <- q
#matrice des composantes "loadings" de la pls de R
P[,i] <- t(x)%*%x%*%w
c <- t(w)%*%t(x)%*%x%*%w
P[,i] <- P[,i]/as.numeric(c)
#mise à jour de la matrice des X
x <- as.matrix(x - t%*%t(P[,i]))
#mise à jour des Y
y.dummies <- y.dummies - t%*%t(q)
#on stocke le vecteur des poids de la composante i dans W[,i]
W[,i] <- w
}
train_pls <- data.frame(Y, Tx)
R2 <- cor(y.dummies, Tx)^2
res <- list("X"=X,
"Y"=Y,
"Yloadings" = Q,
"Yscores" = U,
"Xloadings"= P,
"Xloading.weights" = W,
"Xscores" = Tx,
"TrainPlsData" = train_pls,
"R2" = R2
)
class(res)<-"PLS"
return(res)
}
plsda.pls(Species~., iris, ncomp=2)
data('iris')
library('fastDummies')
plsda.pls <- function(formula, data, ncomp, center = F){
#Vérification que l'entrée est bien une formule Y~X
if(plyr::is.formula(formula)==F){
stop("formula must be R formula !")
}
#Récupération des X et Y
X <- model.matrix(formula, data = data)
X <- X[,-1] #suppression de l'intercept
Y <- model.response(model.frame(formula, data = data))
# Cohérence de Y
if(is.factor(Y)==F && is.vector(Y)==F){stop("Dimension de Y incorrecte") }
if(!(is.factor(Y))){ Y <- as.factor(Y) }
x <- as.matrix(X)
#si le jeu de données entré n'est pas centré
if(center == T){
x <- plsda.scale(X)
x <- as.matrix(x$New, ncol = 1)
}
#y.dummies <- plsda.dummies(Y)
y.dummies <- dummy_cols(Y, select_columns = 'Species', remove_selected_columns = T)
#initialisation de la matrice des poids des composantes de X
W <- data.frame(matrix(rep(0), nrow = ncol(x), ncol=ncomp))
rownames(W) <- colnames(x)
#initialisation de la matrice des composantes de X
P <- data.frame(matrix(rep(0), nrow = ncol(x), ncol=ncomp))
rownames(P) <- colnames(x)
#initialisation de la matrice des scores de X
Tx <- data.frame(matrix(rep(0), nrow = nrow(x), ncol=ncomp))
#initialisation de la matrice des scores de Y
U <- data.frame(matrix(rep(0), nrow = nrow(x), ncol=ncomp))
#initialisation de la matrice des composantes de Y
Q <- data.frame(matrix(rep(0), nrow = ncol(y.dummies), ncol = ncomp))
rownames(Q) <- colnames(y.dummies)
#on déroule l'algorithme NIPALS pour calculer les composantes de X et Y
for(i in 1:ncomp){
#on associe à u la première colonne de Yk-1
u <- as.matrix(y.dummies[,1])
j <- 1
w <- W[,1]
init <- (t(x)%*%u)/sum(u^2)
#on normalise w
init <- init/sqrt(sum(init^2))
#on boucle jusqu'à ce que w converge
while(abs(mean(w)-mean(init)) > 1e-10){
#on n'associe pas init à w au premier tour
if(j > 1){
init <- w
}
#on calcule la composante t de la matrice Xk-1
t <- x%*%init
#calcul des poids de Yk-1
q <- t(y.dummies)%*%t/sum(t^2)
#calcul de la composante u de Xk-1
u <- (y.dummies%*%q)/sum(q^2)
#on met à jour le vecteur de poids
w <- (t(x)%*%u)/sum(u^2)
#on normalise w
w <- w/sqrt(sum(w^2))
j <- j+1
}
#SVD de Y
U[,i] <- u
#SVD de X
Tx[,i] <- t
#matrice des composantes de Y
Q[,i] <- q
#matrice des composantes "loadings" de la pls de R
P[,i] <- t(x)%*%x%*%w
c <- t(w)%*%t(x)%*%x%*%w
P[,i] <- P[,i]/as.numeric(c)
#mise à jour de la matrice des X
x <- as.matrix(x - t%*%t(P[,i]))
#mise à jour des Y
y.dummies <- y.dummies - t%*%t(q)
#on stocke le vecteur des poids de la composante i dans W[,i]
W[,i] <- w
}
train_pls <- data.frame(Y, Tx)
R2 <- cor(y.dummies, Tx)^2
res <- list("X"=X,
"Y"=Y,
"Yloadings" = Q,
"Yscores" = U,
"Xloadings"= P,
"Xloading.weights" = W,
"Xscores" = Tx,
"TrainPlsData" = train_pls,
"R2" = R2
)
class(res)<-"PLS"
return(res)
}
plsda.pls(Species~., iris, ncomp=2)
install.packages(c("devtools", "usethis", "roxygen2"))
test <- c('a','b','c')
chaine <- test[1]
print(chaine)
test <- c('a','b','c')
chaine <- paste(test[1]"~", paste(test[-1], collapse = '+'))
test <- c('a','b','c')
chaine <- paste(test[1],"~", paste(test[-1], collapse = '+'))
chaine
test <- c('a','b','c')
chaine <- paste(test[1],"~", paste(test[-1], collapse = '+'))
as.formula(chaine)
shiny::runApp('Documents/Master/Semestre_1/R/projet/PLSDA_R_Package/Rshiny')
runApp('Documents/Master/Semestre_1/R/projet/PLSDA_R_Package/Rshiny')
runApp('Documents/Master/Semestre_1/R/projet/PLSDA_R_Package/Rshiny')
runApp('Documents/Master/Semestre_1/R/projet/PLSDA_R_Package/Rshiny')
runApp('Documents/Master/Semestre_1/R/projet/PLSDA_R_Package/Rshiny')
runApp('Documents/Master/Semestre_1/R/projet/PLSDA_R_Package/Rshiny')
runApp('Documents/Master/Semestre_1/R/projet/PLSDA_R_Package/Rshiny')
iris
shiny::runApp('Documents/Master/Semestre_1/R/projet/PLSDA_R_Package/Rshiny')
shiny::runApp('Documents/Master/Semestre_1/R/projet/PLSDA_R_Package/Rshiny')
runApp('Documents/Master/Semestre_1/R/projet/PLSDA_R_Package/Rshiny')
runApp('Documents/Master/Semestre_1/R/projet/PLSDA_R_Package/Rshiny')
shiny::runApp('Documents/Master/Semestre_1/R/projet/PLSDA_R_Package/Rshiny')
shiny::runApp('Documents/Master/Semestre_1/R/projet/PLSDA_R_Package/Rshiny')
runApp('Documents/Master/Semestre_1/R/projet/PLSDA_R_Package/Rshiny')
shiny::runApp('Documents/Master/Semestre_1/R/projet/PLSDA_R_Package/Rshiny')
runApp('Documents/Master/Semestre_1/R/projet/PLSDA_R_Package/Rshiny')
shiny::runApp('Documents/Master/Semestre_1/R/projet/PLSDA_R_Package/Rshiny')
shiny::runApp('Documents/Master/Semestre_1/R/projet/PLSDA_R_Package/Rshiny')
shiny::runApp('Documents/Master/Semestre_1/R/projet/PLSDA_R_Package/Rshiny')
shiny::runApp('Documents/Master/Semestre_1/R/projet/PLSDA_R_Package/Rshiny')
runApp('Documents/Master/Semestre_1/R/projet/PLSDA_R_Package/Rshiny')
runApp('Documents/Master/Semestre_1/R/projet/PLSDA_R_Package/Rshiny')
shiny::runApp('Documents/Master/Semestre_1/R/projet/PLSDA_R_Package/Rshiny')
runApp('Documents/Master/Semestre_1/R/projet/PLSDA_R_Package/Rshiny')
runApp('Documents/Master/Semestre_1/R/projet/PLSDA_R_Package/Rshiny')
runApp('Documents/Master/Semestre_1/R/projet/PLSDA_R_Package/Rshiny')
runApp('Documents/Master/Semestre_1/R/projet/PLSDA_R_Package/Rshiny')
shiny::runApp('Documents/Master/Semestre_1/R/projet/PLSDA_R_Package/Rshiny')
shiny::runApp('Documents/Master/Semestre_1/R/projet/PLSDA_R_Package/Rshiny')
shiny::runApp('Documents/Master/Semestre_1/R/projet/PLSDA_R_Package/Rshiny')
shiny::runApp('Documents/Master/Semestre_1/R/projet/PLSDA_R_Package/Rshiny')
shiny::runApp('Documents/Master/Semestre_1/R/projet/PLSDA_R_Package/Rshiny')
shiny::runApp('Documents/Master/Semestre_1/R/projet/PLSDA_R_Package/Rshiny')
runApp('Documents/Master/Semestre_1/R/projet/PLSDA_R_Package/Rshiny')
runApp('Documents/Master/Semestre_1/R/projet/PLSDA_R_Package/Rshiny')
shiny::runApp('Documents/Master/Semestre_1/R/projet/PLSDA_R_Package/Rshiny')
runApp('Documents/Master/Semestre_1/R/projet/PLSDA_R_Package/Rshiny')
runApp('Documents/Master/Semestre_1/R/projet/PLSDA_R_Package/Rshiny')
shiny::runApp('Documents/Master/Semestre_1/R/projet/PLSDA_R_Package/Rshiny')
runApp('Documents/Master/Semestre_1/R/projet/PLSDA_R_Package/Rshiny')
runApp('Documents/Master/Semestre_1/R/projet/PLSDA_R_Package/Rshiny')
shiny::runApp('Documents/Master/Semestre_1/R/projet/PLSDA_R_Package/Rshiny')
runApp('Documents/Master/Semestre_1/R/projet/PLSDA_R_Package/Rshiny')
runApp('Documents/Master/Semestre_1/R/projet/PLSDA_R_Package/Rshiny')
shiny::runApp('Documents/Master/Semestre_1/R/projet/PLSDA_R_Package/Rshiny')
library(ggplot2)
setwd('/home/pierre/Documents/Master/Semestre_1/R/projet/PLSDA_R_Package/code')
source('./split_sample.r')
source('./sel_forward.R')
#source('./plot.R')
source('./fit.R')
source('./cv.R')
source('./scale.r')
source('./dummies.r')
source('./nipals.r')
runApp('~/Documents/Master/Semestre_1/R/projet/PLSDA_R_Package/Rshiny')
library(ggplot2)
setwd('/home/pierre/Documents/Master/Semestre_1/R/projet/PLSDA_R_Package/code')
source('./split_sample.r')
source('./sel_forward.R')
source('./plot.R')
runApp('~/Documents/Master/Semestre_1/R/projet/PLSDA_R_Package/Rshiny')
runApp('~/Documents/Master/Semestre_1/R/projet/PLSDA_R_Package/Rshiny')
